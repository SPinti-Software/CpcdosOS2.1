/*	
	======================================
	==       CPinti ---> CLIENT TCP     ==
	======================================
	
	Developpe entierement par Sebastien FAVIER

	Description
		Module permettant de creer un client TCP/UDP multithread multi I/O
	
	Creation
		19/10/2016
		
	Reecriture
		02/11/2016
		29/11/2016

	Mise a jour
		07/12/2017
		
		07-12-2017	: AMELIORATION du code en suivant une procedure sticte de GCC
		14-02-2017	: Revue des includes et reception + envoie via le buffer cpcdos OK! ;)
	
*/

#include <memory>

#include <cstring>
#include <unistd.h>
#include "cpinti.h"
#include "buffer.h"

#include "func_cpi.h"
#include "debug.h"

#include "socket.h"

#include "client.h"
#include "stack.h"
#include "threads.h"



namespace NP_cpinti_client
{

	int cpinti_client::Demarrer_client(std::string AdresseIP, unsigned int NumPort, unsigned int _NumeroID, int _TYPE_CLIENT)
	{
		// Cette fonction permet de creer un client
		//  _TYPE_CLIENT 	= TCP:2 / UDP:4
		//	AdresseIP		= AdresseIP de l'hote
		//  NumPort			= Numero de port
		//	_NumeroID		= Numero d'itentification unique associe a un processus

		// Retourne :
		//	0	: OK
		// 	-1 	: 
		//	-2	: Erreur de configuration du socket
		//	-3	: Impossible de creer un socket (Driver manquant?)
		//	-4	: Erreur de binding
		//	-5	: Ecoute impossible
		//	-6	: Erreur de descripteur de fichier (select())
		//	-7	: Erreur de lecture de socket (ERRPIPE)
		//  -8	: Impossible de resoudre le nom (DNS)
		//	-9	: Memoire insuffisante
		
		int Resultat_Preparation_SOCKET = 0;
		int Resultat_Connecter_SERVEUR	= 0;
		int Resultat_EXECUTION	 		= 0;
		
		/*********************************************************************************/
		/********* Allocation memoire d'une nouvelle instance d'un socket reseau *********/
		/*********************************************************************************/

		cpinti_dbg::CPINTI_DEBUG(" * Allocation memoire d'une instance d'un socket... ", 
					 " * Memory allocation for network socket... ",
						"cpinti_client", "Demarrer_serveur", Ligne_reste, Alerte_action, Date_avec, Ligne_r_normal);
		
		std::unique_ptr<NP_cpinti_socket::cpinti_socket> instance_socket =
							std::make_unique<NP_cpinti_socket::cpinti_socket>();

		// Verifier si l'allocation a echoue
		if (instance_socket == NULL)
		{
			std::string Erreur_mem = std::string(strerror(errno));
			cpinti_dbg::CPINTI_DEBUG("[ERREUR] Impossible d'allouer de la memoire.\n Raison '" + Erreur_mem + "'", 
						"[ERROR] Unable to allocate memory.\n Reason '" + Erreur_mem + "'",
						"", "", Ligne_saute, Alerte_erreur, Date_sans, Ligne_r_normal);

			return CLIENT_ERR_MEM; 
		} /* Erreur de memoire */
		
		
		std::string ADR = "0x" + std::to_string((unsigned int) &instance_socket);
		std::string SIZ = std::to_string((int) sizeof(instance_socket));
		cpinti_dbg::CPINTI_DEBUG("[OK] --> Allocation offset:" + ADR + " taille:" + SIZ + " octets.", "[OK] --> Allocation offset:" + ADR + " size:" + SIZ + " bytes.", 
						"", "", Ligne_saute, Alerte_ok, Date_sans, Ligne_r_normal);
		
		
		// Ok, on verifie si la preparation du socket a echoue
		Resultat_Preparation_SOCKET = Preparer_Socket(instance_socket, AdresseIP, NumPort, _NumeroID, _TYPE_CLIENT);
		
		// Si il y a un soucis, le message d'erreur est deja logge, on quitte.
		if(Resultat_Preparation_SOCKET < 0)
			return Resultat_Preparation_SOCKET;
		
		
		Resultat_Connecter_SERVEUR = Connecter_Serveur(instance_socket, AdresseIP, NumPort);
	
		// Si il y a un soucis, le message d'erreur est deja logge, on quitte.
		if(Resultat_Connecter_SERVEUR < 0)
		{
			Fermer_Socket(instance_socket);
			return Resultat_Connecter_SERVEUR;
		}

		
		// On finit par executer le serveur!
		Resultat_EXECUTION = Executer_Client(instance_socket);
		
		if(Resultat_EXECUTION < 0)
		{
			Fermer_Socket(instance_socket);
			return Resultat_EXECUTION;
		}
		
		// Et bien sur, lui faire sa petite toilette!
		Fermer_Socket(instance_socket);

		
		return CLIENT_OK;
	} /* DEMARRER_SERVEUR */
	
	int cpinti_client::Executer_Client(std::unique_ptr<NP_cpinti_socket::cpinti_socket> &instance_socket)
	{
		// Cette fonction execute le client
		
		
		// Ceci va permettre de maintenir en vie ou non le serveur (true:OUI false:NON)
		bool CONTINUER_EXECUTION 	= true;
		int Resultat_Select		 	= 0;
		int Code_Erreur				= 0;
		// int Lecture_Client			= 0;
		
		// Recuperer le nombre maximum de clients dans un STRING
		// std::string NombreClientsMAX_STR = std::to_string(instance_socket->get_Nombre_client_MAX());
		
		std::string NumeroID_STR = std::to_string(this->NumeroID);
		
		cpinti_dbg::CPINTI_DEBUG("Lancement du client! TID:" + NumeroID_STR,
								"Starting client! TID:" + NumeroID_STR,
								"", "", Ligne_saute, Alerte_ok, Date_avec, Ligne_r_normal);
								
		/*******************************************************/
		/********  E X E C U T I O N   D U   C L I E N T *******/
		/*******************************************************/
	

		// Declarer celui qui recevra le contenu de la stack
		std::string STACK_MEMOIRE_STR;
		
		// Recupere le numero de port
		unsigned int NoPort = instance_socket->get_Port();
		
		// NoPort en string
		std::string NoPort_STR = std::to_string(NoPort);
		
		// Creer un identifiant unique
		unsigned int ID_gest = this->NumeroID;
		
		// Recuperer l'adresse IP
		std::string AdresseIPClient_STR = instance_socket->get_IP_dest();
		
		
		
		
		while(CONTINUER_EXECUTION)
		{
			usleep(100); 
			
			// Recuperer les donnees stockes dans la stack du serveur
			STACK_MEMOIRE_STR = cpinti::cpinti_GEST_BUFF(ID_gest, _STACK_EXTRACT_POUR_SERVEUR, " ");
			
			// Optimiser
			if(STACK_MEMOIRE_STR.length() > 3)
			{
				// Stopper le serveur
				if(STACK_MEMOIRE_STR == "#STOP") 
				{
					Code_Erreur = SOCK_OK;
					CONTINUER_EXECUTION = false;
				}
				
				// Liberer le CPU pendant 200 ms
				else if(STACK_MEMOIRE_STR == "#DOEVENTS") 
					usleep(280395);
					
				// Envoyer un message au serveur connecte
				else if(STACK_MEMOIRE_STR.find("#SRV# ")!=std::string::npos)	
				{
					instance_socket->Envoyer_Donnees(STACK_MEMOIRE_STR.substr(6), true);
					
					cpinti_dbg::CPINTI_DEBUG("Les donnees ont ete envoye au serveur", 
											"The data has been sent to the server",
											"", "", Ligne_saute, Alerte_ok, Date_avec, Ligne_r_normal);

				}
			}
			

			// Obtenir le numero du "prochain" descripteur de fichier
			Resultat_Select = instance_socket->get_Descripteur();

			
			if(Resultat_Select < 0)
			{
				cpinti_dbg::CPINTI_DEBUG("[ERREUR] Impossible d'obtenir le No du descripteur de fichier.\n Raison '" + instance_socket->get_Erreur()  + "'", 
						"[ERROR] Unable to getting file descriptor number.\n Reason '" + instance_socket->get_Erreur()  + "'",
						"", "", Ligne_saute, Alerte_erreur, Date_sans, Ligne_r_normal);
						
				Code_Erreur = SOCK_ERR_DESCRIPTEUR_SELECT;
				CONTINUER_EXECUTION = false; // Stopper l'execution
			}
			else
			{
				if(Resultat_Select > 0)
				{
					
					if(instance_socket->Recevoir_donnees_client(true) > 0)
					{
						// Recuperer le texte recu
						std::string BUFFER_STR = instance_socket->get_BUFFER();
						// Afficher le texte recu
						
						std::string Socket_STR = std::to_string(Resultat_Select);
						
						std::string Nombre_octets_recu_STR = std::to_string((unsigned int) (size_t)BUFFER_STR.size());
						
						cpinti_dbg::CPINTI_DEBUG("[" + AdresseIPClient_STR + ":" + NoPort_STR + " TCP#" + Socket_STR + "]:" + BUFFER_STR + " (" + Nombre_octets_recu_STR + " o)",
														"[" + AdresseIPClient_STR + ":" + NoPort_STR + " TCP#" + Socket_STR + "]:" + BUFFER_STR + " (" + Nombre_octets_recu_STR + " b)",
														"", "", Ligne_saute, Alerte_surbrille, Date_avec, Ligne_r_normal);

						/** TEMPORAIRE **/
						if(BUFFER_STR == "STOP/") 
						{
							Code_Erreur = SOCK_OK;
							CONTINUER_EXECUTION = false; // Stopper l'execution
						}
						
						BUFFER_STR = "[" + AdresseIPClient_STR + ":" + NoPort_STR + " TCP#" + Socket_STR + "]:" + BUFFER_STR;
						
						
						// Stocker les donnees recues dans la stack du KERNEL
						cpinti::cpinti_GEST_BUFF(ID_gest, _STACK_STOCKER_POUR_CPCDOS, BUFFER_STR);
						
						
					}
					else
					{						
						cpinti_dbg::CPINTI_DEBUG("Le serveur a ferme la connexion.", 
												"Server was closed the connection.",
												"", "", Ligne_saute, Alerte_avertissement, Date_avec, Ligne_r_normal);
						
						Code_Erreur = CLIENT_SERVEUR_FERME;
						CONTINUER_EXECUTION = false; // Stopper l'execution
					}
				}
			}
			
			if(Code_Erreur != SOCK_OK) // Une erreur signalee!!
			{
				CONTINUER_EXECUTION = false; // Stopper l'execution
				break;
			}
		}
	
		return CLIENT_OK; // S'est bien execute!
	} /* EXECUTER_SERVEUR*/
	
	int cpinti_client::Fermer_Socket(std::unique_ptr<NP_cpinti_socket::cpinti_socket> &instance_socket)
	{
		// Fermer la connexion
		if(instance_socket->Fermer_socket()==false)
			cpinti_dbg::CPINTI_DEBUG("[ERREUR] Lors de la fermeture du socket.\n Raison '" + instance_socket->get_Erreur() + "'",
								"[ERROR] During socket closing.\n Reason '" + instance_socket->get_Erreur() + "'",
								"", "", Ligne_saute, Alerte_erreur, Date_sans, Ligne_r_normal);
	
		return CLIENT_OK;
	} /* FERMER_SOCKET */
	
	int cpinti_client::Connecter_Serveur(std::unique_ptr<NP_cpinti_socket::cpinti_socket> &instance_socket, std::string AdresseIP_STR, unsigned int NumPort)
	{
		std::string PORT_STR = std::to_string(NumPort);
		
		// Reserve qu'aux connexions TCP. Car UDP n'a pas besoin d'etablir une connexion ;)
		if(this->TYPE_CLIENT == INIT_CLIENT_TCP)
		{
			// Lancer une ecoute reseau
			cpinti_dbg::CPINTI_DEBUG("Connexion au serveur [" + AdresseIP_STR + ":" + PORT_STR + "]... ",
									"Connecting to the serveur [" + AdresseIP_STR + ":" + PORT_STR + "]... ",
									"", "", Ligne_reste, Alerte_action, Date_avec, Ligne_r_normal);
									
									
			if(instance_socket->Connecter_serveur()==false)
			{
				cpinti_dbg::CPINTI_DEBUG("[ERREUR] Serveur non disponible.\n Raison '" + instance_socket->get_Erreur() + "'",
									"[ERROR] Not avaiable server.\n Reason '" + instance_socket->get_Erreur() + "'",
									"", "", Ligne_saute, Alerte_erreur, Date_sans, Ligne_r_normal);
				return CLIENT_ERR_ECOUTE_SOCK;
			}
		}
		else
			if(this->TYPE_CLIENT == INIT_CLIENT_UDP)
				// Lancer une ecoute reseau UDP
				cpinti_dbg::CPINTI_DEBUG("Preparation de la connexion au serveur [" + AdresseIP_STR + ":" + PORT_STR + "]... ",
										"Preparating server connection [" + AdresseIP_STR + ":" + PORT_STR + "]... ",
										"", "", Ligne_reste, Alerte_action, Date_avec, Ligne_r_normal);
			
		if(instance_socket->Ecouter_socket_FD()==false)
		{
			cpinti_dbg::CPINTI_DEBUG("[ERREUR] Lors de l'ecoute reseau depuis son descripteur de fichier.\n Raison '" + instance_socket->get_Erreur() + "'",
								"[ERROR] During network listening from file descriptor.\n Reason '" + instance_socket->get_Erreur() + "'",
								"", "", Ligne_saute, Alerte_erreur, Date_sans, Ligne_r_normal);
			return CLIENT_ERR_ECOUTE_SOCK;
		}
		
		cpinti_dbg::CPINTI_DEBUG("[OK]", "[OK]", 
					"", "", Ligne_saute, Alerte_ok, Date_sans, Ligne_r_normal);
					
					
		
		return CLIENT_OK;
	} /* PREPARER_ECOUTE */
	
	int cpinti_client::Preparer_Socket(std::unique_ptr<NP_cpinti_socket::cpinti_socket> &instance_socket, std::string AdresseIP, unsigned int NumPort, unsigned int _NumeroID, int _TYPE_CLIENT)
	{

		this->TYPE_CLIENT 	= _TYPE_CLIENT;
		this->NumeroID		= _NumeroID;
		
		// Donner l'IP et le PORT
		instance_socket->set_IP_dest(AdresseIP);
		instance_socket->set_Port(NumPort);
		
		cpinti_dbg::CPINTI_DEBUG(" * Creation d'un nouveau socket reseau... ", 
				 " * Creating new network socket... ",
					"cpinti_client", "Preparer_Socket", Ligne_reste, Alerte_action, Date_avec, Ligne_r_normal);

		/*********************************************************************************/
		/**************** Creer une nouvelle socket dans la classe Socket ****************/
		/*********************************************************************************/
		
		if(instance_socket->Initialiser_socket(this->TYPE_CLIENT) == false)
		{
			cpinti_dbg::CPINTI_DEBUG("[ERREUR] Impossible de creer un socket reseau.\n Raison '" + instance_socket->get_Erreur() + "'", 
						"[ERROR] Unable to create network socket.\n Reason '" + instance_socket->get_Erreur() + "'",
						"", "", Ligne_saute, Alerte_erreur, Date_sans, Ligne_r_normal);
						
			return CLIENT_ERR_INIT_SOCK; // 
		} /* Impossible de creer un socket */

		
		cpinti_dbg::CPINTI_DEBUG("[OK]", "[OK]", 
					"", "", Ligne_saute, Alerte_ok, Date_sans, Ligne_r_normal);
			
		cpinti_dbg::CPINTI_DEBUG(" * Configuration du socket reseau... ", 
				 " * Configuration network socket... ",
					"cpinti_client", "Preparer_Socket", Ligne_reste, Alerte_action, Date_avec, Ligne_r_normal);

					
		/*********************************************************************************/
		/** Configurer le socket par rapport au type selectionne --> "INIT_CLIENT_TCP" **/
		/*********************************************************************************/
		
		if(instance_socket->Configurer_socket() == false)
		{
			cpinti_dbg::CPINTI_DEBUG("[ERREUR] Impossible de configurer le socket reseau.\n Raison '" + instance_socket->get_Erreur() + "'", 
						"[ERROR] Unable to create network socket.\n Reason '" + instance_socket->get_Erreur() + "'",
						"", "", Ligne_saute, Alerte_erreur, Date_sans, Ligne_r_normal);
						
			return CLIENT_ERR_CONFIG_SOCK;
		} /*  Erreur de configuration du socket */
		
		
		cpinti_dbg::CPINTI_DEBUG("[OK]", "[OK]", "", "", Ligne_saute, Alerte_ok, Date_sans, Ligne_r_normal);

	
		/*********************************************************************************/
		/*************** Verifier/Traduire si c'est un NOM DE SERVEUR ********************/
		/*********************************************************************************/
		
		// if(NP_cpinti_socket::cpinti_socket_LOCAL::TestAdresseIPv4(instance_socket->get_IP_dest()) == false) 
			
		// On stocke le nom d'origine de cote
		instance_socket->set_NOM_dest(instance_socket->get_IP_dest());
		
		// On avertit l'operation a l'utilisateur hein soyons pas egoiste! ;)
		cpinti_dbg::CPINTI_DEBUG(" * Resolution DNS si possible de '" + instance_socket->get_NOM_dest() + "'... ", 
				 " * DNS resolution if possible '" + instance_socket->get_NOM_dest() + "'... ",
					"cpinti_client", "Preparer_Socket", Ligne_reste, Alerte_action, Date_avec, Ligne_r_normal);
					
		
		std::string DNS_Resultat;
		
		/**** Traduire si possible en adresse IP ****/
		DNS_Resultat = instance_socket->Resolution_DNS(instance_socket->get_NOM_dest());
		
		// Verifier s'il y a eu une erreur
		if(DNS_Resultat.compare("#ERR")==0)
		{
			cpinti_dbg::CPINTI_DEBUG("[ERREUR] Impossible de resoudre le nom de serveur\n Raison '" + NP_cpinti_socket::cpinti_socket_LOCAL::get_Erreur() + "'", 
					"[ERROR] Unable to resolve name server\n Reason '" + NP_cpinti_socket::cpinti_socket_LOCAL::get_Erreur() + "'",
					"", "", Ligne_saute, Alerte_erreur, Date_sans, Ligne_r_normal);

			return CLIENT_ERR_NOM_DNS; // Impossible de resoudre le nom
		}
		else
		{
			// La traduction s'est bien faite!
			//  On stocke l'IP du serveur
			instance_socket->set_IP_dest(DNS_Resultat);
			
			cpinti_dbg::CPINTI_DEBUG(" [OK] --> " + instance_socket->get_IP_dest(), 
						" [OK] --> " + instance_socket->get_IP_dest(),
						"", "", Ligne_saute, Alerte_ok, Date_sans, Ligne_r_normal);
		}

		/*********************************************************************************/
		/****************** Binder le socket pour le rendre utilisable *******************/
		/*********************************************************************************/

		cpinti_dbg::CPINTI_DEBUG(" * Bindage du socket reseau... ", 
				 " * Binding network socket... ",
					"cpinti_client", "Preparer_Socket", Ligne_reste, Alerte_action, Date_avec, Ligne_r_normal);

		
		if(instance_socket->Binder_socket() == false)
		{
			cpinti_dbg::CPINTI_DEBUG("[ERREUR] Impossible de binder le socket\n Raison '" + NP_cpinti_socket::cpinti_socket_LOCAL::get_Erreur(), 
						"[ERROR] Unable to binding socket\n Reason '" + NP_cpinti_socket::cpinti_socket_LOCAL::get_Erreur(),
						"", "", Ligne_saute, Alerte_erreur, Date_sans, Ligne_r_normal);

				return CLIENT_ERR_BIND_SOCK; // Impossible de binder le socket
		}
		else
			cpinti_dbg::CPINTI_DEBUG("[OK]", "[OK]" ,
							"", "", Ligne_saute, Alerte_ok, Date_sans, Ligne_r_normal);


		return 0; // Preparation du socket OK

	} /* PREPARER_SOCKET */
}

