/*	
	======================================
	==        CPinti ---> Socket        ==
	======================================
	
	Developpe entierement par Sebastien FAVIER

	Description
		Module permettant l'acces aux socket reseaux
	 
	Creation
		19/10/2016
		
	Reecriture
		No.1 28/06/2015
		No.2 12/02/2016
		No.3 20/04/2016
		No.4 02/11/2016
		

	Mise a jour
		29/01/2018
		
		29-01-2018	: OPTIMISATION de la fonction Preparer_reception_TRAME() pour liberer 
									du temps CPU si la machine distante ne repond pas.
		07-12-2017	: AMELIORATION du code en suivant une procedure sticte de GCC
		14-02-2017	: Revue des includes et re-adaptation du serveur & client
		05-01-2017	: Correction bugs mineure avec PING

*/
// #include <strings.h> // TEMPORAIRE !!!

#include <unistd.h>

#include "func_cpi.h"
#include "debug.h"
#include "cpinti.h"
#include "buffer.h"

#include "socket.h"
#include "core.h"

#define reseau

// #include "cpinti.h"

// #include <sys/time.h>
// #include <unistd.h>
// #include <fcntl.h> // fcntl()
// #include <memory>
// #include <iostream>
// #include <sstream>
// #include <cstring>





namespace NP_cpinti_socket
{
	// **** CONSTRUCTEUR **** //
	cpinti_socket::cpinti_socket()
	{
		cpinti_dbg::CPINTI_DEBUG("Module reseau charge avec succes!",
									"Network module loaded with succes!",
									"cpinti_socket", "CONSTRUCTOR", Ligne_reste, Alerte_validation, Date_sans, Ligne_r_normal);
		 
		for(int b = 0; b <= _DEFFERE_FERME-1; b++)
		{
			Ferm_differe_SOCK[b] = 0;
			Ferm_differe_COMP[b] = 0;
		}
	}	
	// **** DESTRUCTEUR **** //
	cpinti_socket::~cpinti_socket()
	{
		TAB_InfoClient.clear();
		
		cpinti_dbg::CPINTI_DEBUG("Module reseau decharge avec succes!",
									"Network module unloaded with succes!",
									"cpinti_socket", "DESCTRUCTOR", Ligne_saute, Alerte_validation, Date_avec, Ligne_r_normal);
	}
	
	void cpinti_socket::THREAD_EVALUATION()
	{
		ENTRER_SectionCritiqueMT();
		
		// S'il depasse 1 seconde
		if(difftime(time(0), this->statistique_temps_depart) >= 1)
		{
			
			this->STATISTIQUES_Client_pass++;
			
			// Delai d'attente avant de considerer qu'un client est inactif
			if(this->STATISTIQUES_Client_pass >= this->STATISTIQUES_Client_temps)
			{
				this->STATISTIQUES_Client_pass = 0;
				
				// S'il sera ou EST egale a 0 alors il reste a 0 (c'est un unsigned)
				if(this->STATISTIQUES_Clients <= 1) 
					this->STATISTIQUES_Clients = 0;
				else
					this->STATISTIQUES_Clients--;
			}
			
			// On mesure l'activite en faisant 
			//  (PAQUETS ENVOYES x PAQUETS RECUS) / NOMBRE CLIENT ACTIF
			if((this->STATISTIQUES_Envoie == 0) && (this->STATISTIQUES_Reception == 0))
				this->STATISTIQUES_Activite = (((this->STATISTIQUES_Envoie) * (this->STATISTIQUES_Reception)));
			else if((this->STATISTIQUES_Envoie > 0) && (this->STATISTIQUES_Reception == 0))
				this->STATISTIQUES_Activite = (((this->STATISTIQUES_Envoie) * (this->STATISTIQUES_Reception+2)));
			else if((this->STATISTIQUES_Envoie == 0) && (this->STATISTIQUES_Reception > 0))
				this->STATISTIQUES_Activite = (((this->STATISTIQUES_Envoie+2) * (this->STATISTIQUES_Reception)));
			else if((this->STATISTIQUES_Envoie > 8 ) && (this->STATISTIQUES_Reception > 8))
				this->STATISTIQUES_Activite = (((this->STATISTIQUES_Envoie+3) * (this->STATISTIQUES_Reception+3)));
			else if((this->STATISTIQUES_Envoie > 8 ) && (this->STATISTIQUES_Reception < 2))
				this->STATISTIQUES_Activite = (((this->STATISTIQUES_Envoie) * (this->STATISTIQUES_Reception+3)));
			else if((this->STATISTIQUES_Envoie < 2 ) && (this->STATISTIQUES_Reception > 8))
				this->STATISTIQUES_Activite = (((this->STATISTIQUES_Envoie+3) * (this->STATISTIQUES_Reception)));
			else
				this->STATISTIQUES_Activite = (((this->STATISTIQUES_Envoie) * (this->STATISTIQUES_Reception)));
			
			// le +1 pour pas multiplier un chiffre null
			
			if(this->STATISTIQUES_Activite > 100) 
				this->STATISTIQUES_Activite = 100; // Ne depasse pas 100%
			else if(this->STATISTIQUES_Activite < 1)
				this->STATISTIQUES_Activite = 0; // Ne sera jamais en dessous de 0
			
			// Recuperer les valeurs publiques
			this->STATISTIQUES_Envoie_Final = this->STATISTIQUES_Envoie;
			this->STATISTIQUES_Reception_Final = this->STATISTIQUES_Reception;
			this->STATISTIQUES_Clients_Final = this->STATISTIQUES_Clients;
			
			
			// cpinti::__CpintiCore_CpcdosOSx__::cpinti_set_net_info(
							// this->PORT, 						/* Numero de port 		*/
							// this->STATISTIQUES_Activite, 		/* Activite de la carte */
							// this->STATISTIQUES_Reception_Final, /* Nb paquets recu 		*/
							// this->STATISTIQUES_Envoie_Final, 	/* Nb paquets envoyes 	*/
							// this->STATISTIQUES_Clients_Final);	/* Nb clients co	 	*/
			
			this->STATISTIQUES_Envoie = 0;
			this->STATISTIQUES_Reception = 0;
			
			// On recalibre le compteur
			this->statistique_temps_depart = time(0);
			
		}
		SORTIR_SectionCritiqueMT();
	}
	
	
	void cpinti_socket::set_THREAD_PRIORITE_YIELD(unsigned int valeur)
	{
		this->THREAD_PRIORITE_YIELD = valeur;
	}
	
	void cpinti_socket::set_THREAD_PRIORITE_DESCRIPTEUR(unsigned int valeur)
	{
		this->THREAD_PRIORITE_DESCRIPTEUR = valeur;
	}
	
	void cpinti_socket::set_THREAD_PRIORITE_SLEEP(unsigned int valeur)
	{
		this->THREAD_PRIORITE_SLEEP = valeur;
	}
	
	unsigned int cpinti_socket::get_THREAD_PRIORITE_YIELD()
	{
		return this->THREAD_PRIORITE_YIELD;
	}
	
	unsigned int cpinti_socket::get_THREAD_PRIORITE_DESCRIPTEUR()
	{
		return this->THREAD_PRIORITE_DESCRIPTEUR;
	}
	
	unsigned int cpinti_socket::get_HREAD_PRIORITE_SLEEP()
	{
		return this->THREAD_PRIORITE_SLEEP;
	}
	
	unsigned int cpinti_socket::get_STATISTIQUES_Activite()
	{
		// Activite en general
		return this->STATISTIQUES_Activite;
	}
	unsigned int cpinti_socket::get_STATISTIQUES_Clients()
	{
		// Nombre de clients actif durant les 2 secondes
		return this->STATISTIQUES_Clients_Final;
	}
	
	unsigned int cpinti_socket::get_STATISTIQUES_Envoie()
	{
		// Nombre de paquets envoyes par secondes
		return this->STATISTIQUES_Envoie_Final;
	} 
	unsigned int cpinti_socket::get_STATISTIQUES_Reception()
	{
		// Nombre de paquets receptionnes par secondes
		return this->STATISTIQUES_Reception_Final;
	}
	
	
	std::string cpinti_socket::get_Erreur()
	{
		// Retourner l'erreur provoque
		return this->Erreur_STR;
	}
	
	std::string cpinti_socket::Resolution_DNS(std::string NomAdresse)
	{
		ENTRER_SectionCritiqueMT();
		
		// Cette fonction permet de traduire une nom de domaine DESTINATION en adresse IP
		//  NomAdresse 	: Nom du serveur
		//	Retourne
		//		L'adresse IP associe au nom du serveur (DNS)

		struct in_addr **ListeAdresses;
		std::string AdresseLst;
		
		// Faire une requete DNS
		this->Sock_hostent = gethostbyname(NomAdresse.c_str());
		
		// Tester si l'operation a fonctionnee
		if(this->Sock_hostent==NULL)
		{
			// Stocker l'erreur dans un attribut membre de la classe qu'on pourrai recuperer
			this->Erreur_STR = std::string(strerror(errno));
			SORTIR_SectionCritiqueMT();
			return "#ERR";
		}
		
		// Si oui, on recupere l'adresse IP
		ListeAdresses = (struct in_addr **)this->Sock_hostent->h_addr_list;
		
		AdresseLst = std::string((char*) inet_ntoa(*ListeAdresses[0]));
		
		SORTIR_SectionCritiqueMT();
		// Et on retourne l'adresse IP :-D
		return AdresseLst;
	}
	
	std::string cpinti_socket::get_IP_dest()
	{
		// Retourner l'ip du destinataire
		return this->AdresseIP_dest_STR;
	}
	
	std::string cpinti_socket::get_IP_src()
	{
		// Retourner l'ip source
		return this->AdresseIP_src_STR;
	}
	
	std::string cpinti_socket::get_NOM_dest()
	{
		// Retourner le nom du destinataire
		return this->AdresseIP_NOM_dest_STR;
	}
	
	std::string cpinti_socket::get_NOM_src()
	{
		// Retourner le nom source
		return this->AdresseIP_NOM_src_STR;
	}
	
	std::string cpinti_socket::get_BUFFER()
	{
		ENTRER_SectionCritiqueMT();
		std::string TMP_BUFFER = this->BUFFER_STR;
		this->BUFFER_STR = "";

		SORTIR_SectionCritiqueMT();
		return TMP_BUFFER;
	}
	
	int cpinti_socket::get_Nombre_client()
	{
		// Retourner le nombre de clients actuellement connectes
		return this->NombreClient_Connectes;
	}
	
	int cpinti_socket::get_Nombre_client_MAX()
	{
		// Retourner le nombre de clients MAX
		return this->NombreClients_MAX;
	}	

	unsigned int cpinti_socket::get_Port()
	{
		// Retourner le numero de port
		return this->PORT;
	}
	
	int cpinti_socket::get_FD_MAX()
	{
		// Retourner le nombre MAX de descripteur de fichier actuel
		return this->FD_MAX;
	}
	
	int cpinti_socket::get_FD_SETSIZE()
	{
		// Retourner la taille du definisseur (1024)
		return FD_SETSIZE;
	}
	
	int cpinti_socket::get_NoSocket()
	{
		// Retourner le numero de socket actuel
		// return this->SocketTemporaire;
		return this->Lecture_Client;
	}
		
	std::string cpinti_socket::get_IP_Client()
	{
		// Retourne l'adresse IP du client courant
		return std::string(inet_ntoa(this->Sock_sockaddr_REP.sin_addr));
	}
	
	std::string cpinti_socket::get_PORT_Client()
	{
		// Retourne le PORT du client courant
		return std::to_string(ntohs (this->Sock_sockaddr_REP.sin_port));
	}
	
	unsigned int cpinti_socket::get_PORT_Client_uint()
	{
		// Retourne le PORT du client courant
		return (unsigned int) (ntohs (this->Sock_sockaddr_REP.sin_port));
	}
	
	
	int cpinti_socket::Verifier_descripteur(int Descripteur)
	{
		// Verifier si le descripteur est valide
		return FD_ISSET(Descripteur, &this->FD_TEMPORAIRE);
	}
	
	bool cpinti_socket::Verifier_correspondance(int Descripteur)
	{
		// Verifier la correspondance du descripteur (descripteur protege!)
		if(Descripteur == this->SocketReseau)
			return true;
		else
			return false;
	}
	
	void cpinti_socket::set_IP_dest(std::string AdresseIP)
	{
		// Retourner l'ip du destinataire
		this->AdresseIP_dest_STR = AdresseIP;
		this->AdresseIP_dest = this->AdresseIP_dest_STR.c_str();
	}
	
	void cpinti_socket::set_IP_src(std::string AdresseIP)
	{
		// Retourner l'ip source
		this->AdresseIP_src_STR = AdresseIP;
		this->AdresseIP_src = this->AdresseIP_src_STR.c_str();
	}
	
	void cpinti_socket::set_NOM_dest(std::string Nom)
	{
		// Retourner le nom du destinataire
		this->AdresseIP_NOM_dest_STR = Nom;
		this->AdresseIP_NOM_dest = this->AdresseIP_NOM_dest_STR.c_str();
	}
	
	void cpinti_socket::set_NOM_src(std::string Nom)
	{
		// Retourner le nom source
		this->AdresseIP_NOM_src_STR = Nom;
		this->AdresseIP_NOM_src = this->AdresseIP_NOM_src_STR.c_str();
	}
	
	void cpinti_socket::set_Nombre_client_MAX(int NbClient)
	{
		// Definir le nombre MAX de clients
		this->NombreClients_MAX = NbClient;
	}
	
	void cpinti_socket::set_Port(unsigned NumPort)
	{
		this->PORT = NumPort;
	}

	bool cpinti_socket::Initialiser_socket(int Type_Socket)
	{
		
		ENTRER_SectionCritiqueMT();
		
		// Cette fonction permet d'initialiser un nouveau socket reseau
		//  Type_Socket :
		//		INIT_PING_ICMP		: Ping ICMP
		// 		INIT_CLIENT_TCP		: Client TCP
		// 		INIT_SERVEUR_TCP	: Serveur TCP
		// 		INIT_CLIENT_UDP		: Client UDP
		// 		INIT_SERVEUR_UDP	: Serveur UDP
		//  Retourne
		//		TRUE : OK
		//		FALSE: Probleme, voir Erreur_STR.

		
		if(Type_Socket == INIT_PING_ICMP) // Ping
		{
			this->Sock_Famille 		= AF_INET; 
			this->Sock_Type 		= SOCK_RAW; 
			this->Sock_Protocol 	= IPPROTO_ICMP;
			
			this->Delai_ms			= ICMP_DELAI_MAX; // 5 secondes pour repondre!
		}
		else if(Type_Socket == INIT_CLIENT_TCP) // Client reseau TCP
		{
			this->Sock_Famille 		= AF_INET; 
			this->Sock_Type 		= SOCK_STREAM; 
			this->Sock_Protocol 	= 0;
		}
		else if(Type_Socket == INIT_SERVEUR_TCP) // Serveur reseau TCP
		{
			this->Sock_Famille 		= AF_INET; 
			this->Sock_Type 		= SOCK_STREAM; 
			this->Sock_Protocol 	= 0;			
		}
		else if(Type_Socket == INIT_CLIENT_UDP) // Client reseau UDP
		{
			this->Sock_Famille 		= AF_INET; 
			this->Sock_Type 		= SOCK_DGRAM; 
			this->Sock_Protocol 	= 0;
		}
		else if(Type_Socket == INIT_SERVEUR_UDP) // Serveur reseau UDP
		{
			this->Sock_Famille 		= AF_INET; 
			this->Sock_Type 		= SOCK_DGRAM; 
			this->Sock_Protocol 	= 0;
		}
		else
		{
			this->Erreur_STR = std::string("[FR] Protocole inconnu / [EN] Unknow protocol");
			this->Type_PROTO = -1;
			return false; // Protocol inconu..
		}
		
		// Cette instance sera pour le protocol attribue
		this->Type_PROTO = Type_Socket;
		
		this->SocketReseau = socket(this->Sock_Famille, this->Sock_Type, this->Sock_Protocol);
		
		SORTIR_SectionCritiqueMT();
		
		if(this->SocketReseau == -1)
		{
			//Stocker l'erreur dans un attribut membre de la classe qu'on pourrai recuperer
			this->Erreur_STR = std::string(strerror(errno));
			return false;
		}
		
		return true;
	}
	
	bool cpinti_socket::Configurer_socket()
	{
		ENTRER_SectionCritiqueMT();
		
		// Cette fonction permet de configurer le socket apres initialisation.
		//  Renvoie
		// 		TRUE : OK
		//		FALSE: Probleme, voir Erreur_STR.

		
		if(this->Type_PROTO == INIT_PING_ICMP) // Ping
		{
			this->TempsMAX.tv_sec = 0;
			this->TempsMAX.tv_usec = 5;
			
			this->Sock_Niveau 			= SOL_SOCKET;
			this->Sock_Option_VAL 		= (char *)&this->TempsMAX;
			this->Sock_Option_TAILLE	= sizeof(this->TempsMAX);
			
			// Configurer la reception
			this->Sock_Option = SO_RCVTIMEO;
	
			if(setsockopt(this->SocketReseau, this->Sock_Niveau, this->Sock_Option, this->Sock_Option_VAL, this->Sock_Option_TAILLE) == -1)
			{
				SORTIR_SectionCritiqueMT();
				// Stocker l'erreur dans un attribut membre de la classe qu'on pourrai recuperer
				this->Erreur_STR = std::string(strerror(errno));
				return false;
			}
			
			// Configurer l'envoi
			this->Sock_Option = SO_SNDTIMEO;
			
			if(setsockopt(this->SocketReseau, this->Sock_Niveau, this->Sock_Option, this->Sock_Option_VAL, this->Sock_Option_TAILLE) == -1)
			{
				SORTIR_SectionCritiqueMT();
				// Stocker l'erreur dans un attribut membre de la classe qu'on pourrai recuperer
				this->Erreur_STR = std::string(strerror(errno));
				return false;
			}

			SORTIR_SectionCritiqueMT();
			// Si tout est OK :)
			return true;
			
		}
		else if(this->Type_PROTO == INIT_CLIENT_TCP) // Client reseau TCP
		{
	
			this->TempsMAX.tv_sec = 0;
			this->TempsMAX.tv_usec = 5;
			
			int OPT_VAL = 1;
			this->Sock_Niveau 			= SOL_SOCKET;
			this->Sock_Option 			= SO_REUSEADDR;
			this->Sock_Option_VAL 		= (void*)&OPT_VAL;
			this->Sock_Option_TAILLE	= sizeof(int);
			
			if(setsockopt(this->SocketReseau, this->Sock_Niveau, this->Sock_Option, this->Sock_Option_VAL, this->Sock_Option_TAILLE) == -1)
			{
				SORTIR_SectionCritiqueMT();
				
				//Stocker l'erreur dans un attribut membre de la classe qu'on pourrai recuperer
				this->Erreur_STR = std::string(strerror(errno));
				return false;
			}
			

			this->Sock_Niveau 			= SOL_SOCKET;
			this->Sock_Option_VAL 		= (char *)&this->TempsMAX;
			this->Sock_Option_TAILLE	= sizeof(this->TempsMAX);
			
			// Configurer la reception
			this->Sock_Option = SO_RCVTIMEO;
	
			if(setsockopt(this->SocketReseau, this->Sock_Niveau, this->Sock_Option, this->Sock_Option_VAL, this->Sock_Option_TAILLE) == -1)
			{
				SORTIR_SectionCritiqueMT();
				
				// Stocker l'erreur dans un attribut membre de la classe qu'on pourrai recuperer
				this->Erreur_STR = std::string(strerror(errno));
				return false;
			}
			
			// Configurer l'envoi
			this->Sock_Option = SO_SNDTIMEO;
			
			if(setsockopt(this->SocketReseau, this->Sock_Niveau, this->Sock_Option, this->Sock_Option_VAL, this->Sock_Option_TAILLE) == -1)
			{
				SORTIR_SectionCritiqueMT();
				
				// Stocker l'erreur dans un attribut membre de la classe qu'on pourrai recuperer
				this->Erreur_STR = std::string(strerror(errno));
				return false;
			}

			// Si tout est OK :)
			return true;
			
		}
		else if(this->Type_PROTO == INIT_SERVEUR_TCP) // Serveur reseau TCP
		{
			// Va servir pour l'ecoute via le descripteur de fichier
			this->TempsMAX.tv_sec = 0;
			this->TempsMAX.tv_usec = 5;
			
			int OPT_VAL = 1;
			this->Sock_Niveau 			= SOL_SOCKET;
			this->Sock_Option 			= SO_REUSEADDR; // Configurer la "reutilisation" de l'adresse meme si le socket est ouvert
			this->Sock_Option_VAL 		= (void*)&OPT_VAL;
			this->Sock_Option_TAILLE	= sizeof(int);
			
			if(setsockopt(this->SocketReseau, this->Sock_Niveau, this->Sock_Option, this->Sock_Option_VAL, this->Sock_Option_TAILLE) == -1)
			{
				SORTIR_SectionCritiqueMT();
				// Stocker l'erreur dans un attribut membre de la classe qu'on pourrai recuperer
				this->Erreur_STR = std::string(strerror(errno));
				return false;
			}
			
			SORTIR_SectionCritiqueMT();
			return true;			
		}
		else if(this->Type_PROTO == INIT_CLIENT_UDP) // Client reseau UDP
		{
			SORTIR_SectionCritiqueMT();
			// Si tout est OK :)
			return true;
		}
		else if(this->Type_PROTO == INIT_SERVEUR_UDP) // Serveur reseau UDP
		{
			this->TempsMAX.tv_sec = 0;
			this->TempsMAX.tv_usec = 0;
			
			
			// int OPT_VAL = 1;
			this->Sock_Niveau 			= SOL_SOCKET;
			this->Sock_Option_VAL 		= (void*)&this->TempsMAX;
			this->Sock_Option_TAILLE	= sizeof(this->TempsMAX);
			
			// Configurer la reception
			this->Sock_Option = SO_RCVTIMEO;
			
			if(setsockopt(this->SocketReseau, this->Sock_Niveau, this->Sock_Option, (const void*) &this->TempsMAX, sizeof(this->TempsMAX)) < 0)
			{
				SORTIR_SectionCritiqueMT();
				// Stocker l'erreur dans un attribut membre de la classe qu'on pourrai recuperer
				this->Erreur_STR = std::string(strerror(errno));
				return false;
			}
			
			// Configurer l'envoi
			this->Sock_Option = SO_SNDTIMEO;
			
			if(setsockopt(this->SocketReseau, this->Sock_Niveau, this->Sock_Option,  (const void*) &this->TempsMAX, sizeof(this->TempsMAX)) < 0)
			{
				SORTIR_SectionCritiqueMT();
				// Stocker l'erreur dans un attribut membre de la classe qu'on pourrai recuperer
				this->Erreur_STR = std::string(strerror(errno));
				return false;
			}
			
			// fcntl(this->SocketReseau, F_SETFL, O_NONBLOCK); 
		}
		else
		{
			SORTIR_SectionCritiqueMT();
			this->Erreur_STR = std::string("[FR] Protocole inconnu / [EN] Unknow protocol");
			return false; // Protocol inconu..
		}
		
		SORTIR_SectionCritiqueMT();
		
		return true;
	}

	bool cpinti_socket::Binder_socket()
	{
		// Cette fonction permet de binder le socket reseau afin de le rendre utiliable
		//  Renvoie
		// 		TRUE : OK
		//		FALSE: Probleme, voir Erreur_STR.
		
		// Declarer les 3 principaux attributs
		// int Sock_Famille; //, Sock_Type, Sock_Protocol;
		
		ENTRER_SectionCritiqueMT();
		
		if(this->Type_PROTO == INIT_PING_ICMP) // Ping
		{
			
			bzero((char *) &Sock_sockaddr, sizeof(Sock_sockaddr));
			
			// Protocole familiale IP
			this->Sock_sockaddr.sin_family = this->Sock_Famille;
			
			// On copie h_addr vers s_addr
			bcopy((char *) this->Sock_hostent->h_addr,
					(char *) &this->Sock_sockaddr.sin_addr.s_addr,
								(size_t) this->Sock_hostent->h_length);
			
			
			
			// Source = IP du serveur
			// this->Sock_sockaddr.sin_addr.s_addr = inet_addr(this->get_IP_dest().c_str()); // Adresse IP distant
			
			// Personne ne peut expliquer pourquoi, que ca soit en big ou little Indien
			//  il est conseille de remplir sin_zero de 8 octets a '0'. Question de compatibilite.
			memset(&(this->Sock_sockaddr.sin_zero), '\0', 8);
		
			// Nettoyer le tout
			// FD_ZERO(&this->FD_socket);
			// FD_CLR (this->SocketReseau, &this->FD_socket);
		
			// Ajouter "l'ecoute" du descripteur de fichiers
			// FD_SET(this->SocketReseau, &this->FD_socket);
			
			// Obtenir le nombre maximum de descripteur de fichiers
			// this->FD_MAX = this->SocketReseau;
		
		}
		else if(this->Type_PROTO == INIT_CLIENT_TCP) // Client reseau TCP
		{				
			
			bzero((char *) &Sock_sockaddr, sizeof(Sock_sockaddr));
			
			// Protocole familiale IP
			this->Sock_sockaddr.sin_family		= this->Sock_Famille;
			
			// On copie h_addr vers s_addr
			bcopy((char *) this->Sock_hostent->h_addr,
					(char *) &this->Sock_sockaddr.sin_addr.s_addr,
								(size_t) this->Sock_hostent->h_length);
							  
			// Port du serveur distant
			this->Sock_sockaddr.sin_port		= htons(this->PORT);
			
			////Source = IP du serveur
			// this->Sock_sockaddr.sin_addr.s_addr = inet_addr(this->get_IP_dest().c_str()); // Adresse IP host

			// Personne ne peut expliquer pourquoi, que ca soit en big ou little Indien
			//  il est conseille de remplir sin_zero de 8 octets a '0'. Question de compatibilite.
			memset(&(this->Sock_sockaddr.sin_zero), '\0', 8);
			
		}
		else if(this->Type_PROTO == INIT_SERVEUR_TCP) // Serveur reseau TCP
		{
			this->Sock_sockaddr.sin_family		= this->Sock_Famille;
			this->Sock_sockaddr.sin_addr.s_addr = htonl(INADDR_ANY); // Toutes adresse
			this->Sock_sockaddr.sin_port		= htons(this->PORT);
			
			// Mise a zero du compteur de clients
			this->NombreClient_Connectes = 0;
			
			// Personne ne peut expliquer pourquoi, que ca soit en big ou little Indien
			//  il est conseille de remplir sin_zero de 8 octets a '0'. Question de compatibilite.
			memset(&(this->Sock_sockaddr.sin_zero), '\0', 8);
			
			// Binder le socket
			if(bind(this->SocketReseau, (struct sockaddr*) &this->Sock_sockaddr, sizeof(this->Sock_sockaddr)) < 0)
			{
				// Retourner l'erreur
				this->Erreur_STR = std::string("bind():");
				this->Erreur_STR = this->Erreur_STR + std::string(strerror(errno));
				
				SORTIR_SectionCritiqueMT();
				return false;
			}
		
		}
		else if(this->Type_PROTO == INIT_CLIENT_UDP) // Client reseau UDP
		{
			memset(&(this->Sock_sockaddr), '\0', sizeof(this->Sock_sockaddr)); // CLEAN
			
			// Protocole familiale IP
			this->Sock_sockaddr.sin_family		= this->Sock_Famille;
			
			// Source = IP du serveur
			this->Sock_sockaddr.sin_addr.s_addr = inet_addr(this->get_IP_dest().c_str()); // Adresse IP host
			
			// On copie h_addr vers s_addr
			memcpy((char*) this->Sock_hostent->h_addr,
					(char*) &this->Sock_sockaddr.sin_addr,
							  (size_t) this->Sock_hostent->h_length);
							  
			
			
			// Port du serveur distant
			this->Sock_sockaddr.sin_port		= htons(this->PORT);
			
			// Personne ne peut expliquer pourquoi, que ca soit en big ou little Indien
			//  il est conseille de remplir sin_zero de 8 octets a '0'. Question de compatibilite.
			memset(&(this->Sock_sockaddr.sin_zero), '\0', 8);
			
			
			// Binder le socket
			/* if(bind(this->SocketReseau, (struct sockaddr*) &this->Sock_sockaddr, sizeof(this->Sock_sockaddr)) < 0)
			{
				// Retourner l'erreur
				this->Erreur_STR = std::string("bind():");
				this->Erreur_STR = this->Erreur_STR + std::string(strerror(errno));
				
				return false;
			} */
			
		}
		else if(this->Type_PROTO == INIT_SERVEUR_UDP) // Serveur reseau UDP
		{
			this->Sock_sockaddr.sin_family		= this->Sock_Famille;
			this->Sock_sockaddr.sin_addr.s_addr = htonl(INADDR_ANY); // Toutes adresse
			this->Sock_sockaddr.sin_port		= htons(this->PORT);
			
			// Mise a zero du compteur de clients
			this->NombreClient_Connectes = 0;
			
			// Personne ne peut expliquer pourquoi, que ca soit en big ou little Indien
			//  il est conseille de remplir sin_zero de 8 octets a '0'. Question de compatibilite.
			memset(&(this->Sock_sockaddr.sin_zero), '\0', 8);

			// Binder le socket
			if(bind(this->SocketReseau, (struct sockaddr*) &this->Sock_sockaddr, sizeof(this->Sock_sockaddr)) < 0)
			{
				// Retourner l'erreur
				this->Erreur_STR = std::string("bind():");
				this->Erreur_STR = this->Erreur_STR + std::string(strerror(errno));
				
				SORTIR_SectionCritiqueMT();
				return false;
			}
		}
		else
		{
			this->Erreur_STR = std::string("[FR] Protocole inconnu / [EN] Unknow protocol");
			
			SORTIR_SectionCritiqueMT();
			return false; // Protocol inconu..
		}

		SORTIR_SectionCritiqueMT();
		return true;
	}
	
	bool cpinti_socket::Connecter_serveur()
	{
	
		ENTRER_SectionCritiqueMT();
		this->STATISTIQUES_Envoie++;

		// Cette fonction permet de connecter un socket sur un serveur
		if(connect(this->SocketReseau,(struct sockaddr *) &this->Sock_sockaddr,sizeof(this->Sock_sockaddr)) < 0) 
		{
			if(errno == 43) // EINPROGRESS
			{
				perror("connect()");
			}
			else
			{
				// Probleme..
				this->Erreur_STR = std::string("connect():");
				this->Erreur_STR = this->Erreur_STR + std::string(strerror(errno));
				
			}
			SORTIR_SectionCritiqueMT();
			return false;
		}
		
		this->STATISTIQUES_Reception++;
		
		SORTIR_SectionCritiqueMT();
		return true; // OK
	}
	
	bool cpinti_socket::Ecouter_socket()
	{
		ENTRER_SectionCritiqueMT();
		// Cette fonction permet de lancer une ecoute du reseau via son socket
		if(listen(this->SocketReseau, this->NombreClients_MAX /*MAX*/ + 4 /*MARGE*/ ) == -1)
		{
			// Probleme..
			this->Erreur_STR = std::string("listen():");
			this->Erreur_STR = this->Erreur_STR + std::string(strerror(errno));
			
			SORTIR_SectionCritiqueMT();
			return false;
		}
		
		return true; // OK
	}
	
	bool cpinti_socket::Ecouter_socket_FD()
	{
		// Cette fonction permet de lancer une ecoute du reseau via son socket DEPUIS son descripteur de fichier
	
		ENTRER_SectionCritiqueMT();
		
		// Nettoyer le tout
		FD_ZERO(&this->FD_socket);
		FD_CLR (this->SocketReseau, &this->FD_socket);
		
		FD_ZERO(&this->FD_TEMPORAIRE);
		FD_CLR (this->SocketReseau, &this->FD_TEMPORAIRE);
		
		FD_SET(this->SocketReseau, &this->FD_socket);
		
		// Obtenir la taille maximale
		this->FD_MAX = this->SocketReseau;
		
		if(Type_PROTO == INIT_CLIENT_UDP)
			FD_SET(this->SocketReseau, &this->FD_socket);
		
		SORTIR_SectionCritiqueMT();
		return true; // OK
	}
	
	bool cpinti_socket::Accepter_connexion()
	{
		ENTRER_SectionCritiqueMT();
		// Cette fonction permet d'accepter une connexion via un socket
		int Taille_Adresse = sizeof(this->Sock_sockaddr_REP);
		
		this->STATISTIQUES_Envoie++;
		this->STATISTIQUES_Reception++;
		
		// Accepter la connexion depuis le socket serveur courant
		this->SocketTemporaire = accept(this->SocketReseau, (struct sockaddr *)&this->Sock_sockaddr_REP, &Taille_Adresse);
		
		this->Lecture_Client = this->SocketTemporaire;
		
		if(this->SocketTemporaire < 0)
		{
			// Oups probleme
			this->Erreur_STR = std::string("accept():");
			this->Erreur_STR = this->Erreur_STR + std::string(strerror(errno));
			
			SORTIR_SectionCritiqueMT();
			return false;
		}
		else
		{
			// Nettoyer le tableau si on a debuter
			if(this->NombreClient_Connectes == 0)
				this->TAB_InfoClient.clear();
			
			// Augmente le nombre de connectes
			this->NombreClient_Connectes++;
			
			SORTIR_SectionCritiqueMT();
			return true; // Ok
		}
	}
	
	bool cpinti_socket::Ajouter_Client()
	{
		// Cette fonction permet de lier le descripteur du socket client avec celui du serveur
		ENTRER_SectionCritiqueMT();
		FD_SET(this->SocketTemporaire, &this->FD_socket);
		
		// S'il y a plus de clients, alors son recalibre
		if(this->SocketTemporaire > this->FD_MAX)
			this->FD_MAX = this->SocketTemporaire;
		
		// Ajouter ses informations depuis un vector (Sert pour la deconnexion/envoie general ou precise)
		this->TAB_InfoClient.push_back( {get_IP_Client(), get_PORT_Client_uint(), this->SocketTemporaire} );
	
		SORTIR_SectionCritiqueMT();
		return true;
	}
	
	bool cpinti_socket::RefuserClient()
	{
		// Cette fonction permet de "fermer" la connexion d'un client COURANT

		// return Fermer_SocketClient(this->SocketTemporaire);
		
		// On ajoute dans la liste des fermetures differes
		return Fermeture_differe_ADD(this->SocketTemporaire);
	}
	
	bool cpinti_socket::RefuserClient(std::string Cause)
	{
		// Cette fonction permet de "fermer" la connexion d'un client COURANT
		//  de maniere differe!
		
		// Avertir le client du motif de refus
		Envoyer_Donnees("[FR] Connexion refusee / [EN] Refused connection.\r\nCAUSE:'" + Cause + "'");
		
		// On ajoute dans la liste des fermetures differes
		return Fermeture_differe_ADD(this->SocketTemporaire);
	}
	

	bool cpinti_socket::Attribuer_descr_lecture(int descripteur)
	{
		this->Lecture_Client = descripteur;
		return true;
	}
	
	int cpinti_socket::get_Descripteur()
	{
		// Cette fonction retourne le descripteur de fichier "client" / "suivant"
		//
		// Retourne
		//		0 : OK
		//		-1: Probleme interne, descripteur de fichier select()

		ENTRER_SectionCritiqueMT();
		
		int Resultat_Select = 0;
		
		// Si le serveur est en TCP
		if((this->Type_PROTO == INIT_SERVEUR_TCP) 
			|| (this->Type_PROTO == INIT_CLIENT_TCP))
		{
			// Copier temporairement le descripteur principal
			memcpy(&this->FD_TEMPORAIRE, &this->FD_socket, sizeof(this->FD_TEMPORAIRE));

			// Recuperer/verifier le resultat s'il y a eu un changement
			Resultat_Select = select(this->FD_MAX+1, &this->FD_TEMPORAIRE, NULL, NULL, &this->TempsMAX);
		}
		// Si le serveur est en UDP
		else if((this->Type_PROTO == INIT_SERVEUR_UDP) || (this->Type_PROTO == INIT_CLIENT_UDP))
		{
			// Receptionner directement la requete UDP
			if(Recevoir_TRAME() == true)
				Resultat_Select = 1;
			else
				Resultat_Select = 0;
		}

		// S'il y a une erreur
		if(Resultat_Select < 0)
		{
			if(this->Type_PROTO == INIT_SERVEUR_TCP)
				this->Erreur_STR = std::string("select():");
			
			else if(this->Type_PROTO == INIT_SERVEUR_UDP)
				this->Erreur_STR = std::string("recvfrom() UDP:");

			this->Erreur_STR = this->Erreur_STR + std::string(strerror(errno));
		}
		
		SORTIR_SectionCritiqueMT();
		
		usleep(this->THREAD_PRIORITE_DESCRIPTEUR); // 1ms
		
		
		// Retourner le resultat
		return Resultat_Select;
		
	}
	
	bool cpinti_socket::Envoyer_TRAME(unsigned int Taille, const void* PAQUET)
	{
		// Cette fonction permet d'envoyer la trame sur le reseau
		// Taille : Taille de la trame
		
		// Retourne
		//		TRUE : OK
		//		FALSE: Probleme!
		
		ENTRER_SectionCritiqueMT();
		
		int Resultat;
		
		this->STATISTIQUES_Envoie++;
		
		Resultat = sendto(this->SocketReseau, PAQUET, (int) Taille, MSG_DONTWAIT, (struct sockaddr *)&this->Sock_sockaddr, sizeof(this->Sock_sockaddr));
		if (Resultat < 0 || Resultat != (int) Taille)
		{
			this->Erreur_STR = std::string("sendto():");
			this->Erreur_STR = this->Erreur_STR + std::string(strerror(errno));
			SORTIR_SectionCritiqueMT();
			return false;
		}
		else
		{
			SORTIR_SectionCritiqueMT();
			return true; // OK
		}
		
		
		SORTIR_SectionCritiqueMT();
		usleep(0);
	
	}
	
	int cpinti_socket::Envoyer_Donnees(std::string DONNEES_STR, bool AuServeur)
	{
		// Permet d'envoyer des donnes au socket PRINCIPAL ou courant
		// AuServeur 	= TRUE : PRINCIPAL
		//				= FALSE: COURANT
		
		if(AuServeur == true)
			// Envoyer des donnees au socket principal
			return Envoyer_Donnees(DONNEES_STR, this->SocketReseau);
		else
			// Envoyer des donnees au socket courant
			return Envoyer_Donnees(DONNEES_STR, this->SocketTemporaire);
	}
	
	int cpinti_socket::Envoyer_Donnees(std::string DONNEES_STR)
	{
		// Permet d'envoyer des donnees au socket courant
		return Envoyer_Donnees(DONNEES_STR, this->SocketTemporaire);
	}
	
	
	int cpinti_socket::Envoyer_Donnees_TOUT_CLIENTS(std::string DONNEES_STR)
	{
		// Cette fonction permet d'envoyer des donnes a TOUS les sockets connectes
		// Renvoei le nombre de requette qui ont reussi a s'envoyer!
		int Resultat_Envoi_NB = 0;
		
		// On boucle de zero --> Nombre max de clients connectes
		for(unsigned int b = 0; b < this->TAB_InfoClient.size();  b++)
		{
			// Fermer tous les vectors qui ont minimum un port ET un socket superieur a 0 (securite)
			if((this->TAB_InfoClient[b].port > 0) && (this->TAB_InfoClient[b].socket > 0))
			{
				// Envoyer la trame!
				int Resultat_Envoi = Envoyer_Donnees(DONNEES_STR, this->TAB_InfoClient[b].socket);
				
				usleep(this->THREAD_PRIORITE_YIELD);
				
				// Incrementer le nombre d'envois reussis
				if(Resultat_Envoi > 0) 
					Resultat_Envoi_NB++;
			}
		}
		
		// Renvoyer le nombre d'envois avec succes
		return Resultat_Envoi_NB;
	}
	
	int cpinti_socket::Envoyer_Donnees(std::string DONNEES_STR, int Socket)
	{
		ENTRER_SectionCritiqueMT();
		// Permet d'envoyer des donnees a un socket precis
		int Resultat_Envoi = 0;
		bool Resultat_EnvoieB = true;
		
		// Envoyer les donnes
		if(this->Type_PROTO == INIT_CLIENT_UDP)
		{
			// Envoyer la trame UDP
			Resultat_EnvoieB = Envoyer_TRAME((size_t) DONNEES_STR.size(), (const char*) DONNEES_STR.c_str());
			
			// Si une erreur se produit avec l'envoie UDP alors on signale l'erreur
			if(Resultat_EnvoieB == false)
				Resultat_Envoi = -1;
		}
		else
		{
			this->STATISTIQUES_Envoie++;
			
			// Envoyer la trame TCP
			Resultat_Envoi = send(Socket, (const char*) DONNEES_STR.c_str(), (int) DONNEES_STR.size(), MSG_NOSIGNAL);
		}
		
		SORTIR_SectionCritiqueMT();
		usleep(0);
		
		// Verifier si tout s'est bien passe!
		if(Resultat_Envoi < 0)
		{
			switch (errno) 
			{
				case EPIPE:{
					if(Resultat_EnvoieB == false) // UDP
						this->Erreur_STR = std::string("Signal Broken pipe -> sendto():");
					else // TCP
						this->Erreur_STR = std::string("Signal Broken pipe -> send():");
					this->Erreur_STR = this->Erreur_STR + std::string(strerror(errno));
					// Fermer_socket(Socket)
					return Resultat_Envoi;
				}
				default:{
					// Si le client a un PB on ferme sa connexion
					this->Erreur_STR = std::string("send():");
					this->Erreur_STR = this->Erreur_STR + std::string(strerror(errno));
					// Fermer_socket(Socket)
					return Resultat_Envoi;

				}
			}	
		}
		else
			return Resultat_Envoi; // Ok
	}
	
	bool cpinti_socket::Preparer_reception_TRAME()
	{
		// Cette fonction permet de configurer la reception d'une trame 
		//  Retourne
		//		TRUE: Requete receptionne
		//		FALSE: Pas recu..
		
		ENTRER_SectionCritiqueMT();
		int	selectTrouve = 0;
		struct timeval IntervalleTemps;
		fd_set FD_Lecture, FD_Ecriture;

		// Temps d'attente du select
		IntervalleTemps.tv_sec	= 0;
		IntervalleTemps.tv_usec = 100; // 1 sec

		// Reset les descripteur de fichier
		FD_ZERO (&FD_Lecture);
		FD_ZERO (&FD_Ecriture);
		
		// Definit le socket sur l'ecoute du descripteur du fichier
		FD_SET (this->SocketReseau, &FD_Lecture);
		
		// Obtenir le temps
		time_t current_time_init = time(NULL);
		time_t current_time = time(NULL);
		
		// Comparer et boucler durant 2 secondes
		for(int b = 0; b < 50 && selectTrouve < 1; b++)
			while (current_time <= (current_time_init + 1) + (time_t) this->Delai_ms )
			{
				selectTrouve = select (this->SocketReseau+1, &FD_Lecture, &FD_Ecriture, NULL, &IntervalleTemps);
				if(selectTrouve != 0) break; // Si il y a tout de suite une reponse
				
				
				// Recuperer le temps
				current_time = time(NULL);
				
				SORTIR_SectionCritiqueMT();
				usleep(this->THREAD_PRIORITE_YIELD);
				ENTRER_SectionCritiqueMT();
			}
		
		// Nettoyer le descripteur de fichier de la lecture
		FD_ZERO (&FD_Lecture);
		FD_CLR (this->SocketReseau, &FD_Lecture);

		// Et de l'ecriture
		FD_ZERO (&FD_Ecriture);
		FD_CLR (this->SocketReseau, &FD_Ecriture);
		
		SORTIR_SectionCritiqueMT();
		// La machine n'a pas repondu assez vite ou pas du tout..
		if (selectTrouve == 0)
			return false;
		
		return true;
	}
	
	bool cpinti_socket::Recevoir_TRAME()
	{
		
		this->STATISTIQUES_Reception += 5;
		
		/////////// T E M P O R A I R E /////////
		return true;
		/////////////////////////////////////////
		
		// Taille du buffer
		unsigned int TAILLE_BUFFER;
		
		if((this->Type_PROTO == INIT_SERVEUR_UDP) || (this->Type_PROTO == INIT_CLIENT_UDP))
			TAILLE_BUFFER = ALLOC_MAX_BUFFER_SERVEUR; /* UDP seulement */
		else
			TAILLE_BUFFER = ALLOC_MAX_BUFFER_PING; /* Autrement, ICMP */
		
		char *BUFFER = new char[TAILLE_BUFFER]; // Buffer principal

		// Remplir le buffer de ZEROS
		memset(BUFFER, '\0', sizeof(char)*TAILLE_BUFFER);
		
		int Taille;
		int TailleRequeteRecu;
		
		// socklen_t Taille = sizeof((struct sockaddr *)&this->Sock_sockaddr_REP);
		
		// Receptionner la trame
		if(Type_PROTO == INIT_CLIENT_UDP)
		{
			Taille = sizeof (this->Sock_sockaddr);
			TailleRequeteRecu = recvfrom (this->SocketReseau, (void*) BUFFER, (size_t) sizeof(BUFFER), 0, (struct sockaddr *) &this->Sock_sockaddr, &Taille);
		}
		else
		{
			Taille = sizeof (this->Sock_sockaddr_REP);
			TailleRequeteRecu = recvfrom (this->SocketReseau, (void*) BUFFER, (size_t) sizeof(BUFFER), MSG_DONTWAIT, (struct sockaddr *) &this->Sock_sockaddr_REP, &Taille);
		}
		
		if (TailleRequeteRecu < 0)
		{
			// Serveur TCP
			if(this->Type_PROTO == INIT_SERVEUR_UDP)
			{ // Protocole UDP
				// Recuperer le numero d'erreur
				int numero_err = errno;

				// Controler l'erreur car le descripteur du serveur UDP est definit
				//  sur le O_NONBLOCK afin de pas rester bloquer sur la reception d'un paquet
				if((TailleRequeteRecu < 0) &&
					((numero_err == EWOULDBLOCK) || (numero_err == EAGAIN) || (numero_err == ENOMSG)))
						TailleRequeteRecu = 0;
				
				if(TailleRequeteRecu < 1)
					return false; // Ohf...
				else
					return true; // Ok
			}
			else // Autres protocoles
			{
				this->Erreur_STR = std::string("recvfrom():");
				this->Erreur_STR = this->Erreur_STR + std::string(strerror(errno));
				return false;
			}
		}
		else
		{
			this->STATISTIQUES_Reception++;
			
			// Transferer les donnees dans un buffer auto-buffered
			this->BUFFER_STR = std::string(BUFFER);
			
			// Remplir le buffer de ZEROS
			memset(BUFFER, '\0', sizeof(char)*TAILLE_BUFFER);
			
			delete[] BUFFER;
			
			// OK
			return true;
		}
	}
	
	int cpinti_socket::Recevoir_donnees_client()
	{
		return Recevoir_donnees_client(this->Lecture_Client);
	}
	
	int cpinti_socket::Recevoir_donnees_client(bool AuServeur)
	{
		// Cette fonction permet de receptionner les donnees d'un socket COURANT
		//  renvoie la taille en octets et stock de cote les donnees

			// Envoyer des donnees au socket courant
		if(AuServeur == true)
			return Recevoir_donnees_client(this->SocketReseau);
		else
			return Recevoir_donnees_client(this->SocketTemporaire);
	}
	
	int cpinti_socket::Recevoir_donnees_client(int Socket)
	{
		// Cette fonction permet de receptionner les donnees d'un socket COURANT
		//  renvoie la taille en octets et stock de cote les donnees
		
		ENTRER_SectionCritiqueMT();
		
		int Reception_res;
		
		if(this->Type_PROTO == INIT_CLIENT_UDP) // UDP
		{
			bool Reception_resB = Recevoir_TRAME();
			if(Reception_resB == false)
				Reception_res = -1;
			else
				Reception_res = (int) this->BUFFER_STR.size();
		}
			
		else
		{
			// Declarer un buffer
			char BUFFER[ALLOC_MAX_BUFFER_SERVEUR]; // 2^14 o
			
			this->STATISTIQUES_Reception += 1 + int(sizeof(BUFFER) / 2);
			
			// Remplir le buffer de ZEROS
			memset(BUFFER, '\0', sizeof(char)*ALLOC_MAX_BUFFER_SERVEUR);

			// Receptionner les donnees
			Reception_res = (int) recv(Socket, (char*) BUFFER, sizeof(BUFFER), 0);

			// Transferer les donnees dans un buffer auto-buffered
			this->BUFFER_STR = std::string(BUFFER);
			
			// Remplir le buffer de ZEROS
			memset(BUFFER, '\0', sizeof(char)*ALLOC_MAX_BUFFER_SERVEUR);
			
		}
		
		SORTIR_SectionCritiqueMT();
		
		// Renvoie la taille
		return Reception_res;
	}
	
	bool cpinti_socket::Fermer_socket()
	{
		return Fermer_socket(true);
	}
	bool cpinti_socket::Fermer_socket(bool AuServeur)
	{
		if(AuServeur == true)
			return Fermer_socket(this->SocketReseau);
		else if(AuServeur == false)
			return Fermer_socket(this->SocketTemporaire);
		
		return true;
	}
	bool cpinti_socket::Fermer_socket(int Socket)
	{
		// Cette fonction permet de fermer "correctement" un socket reseau
		// Retourne
		//		TRUE : OK
		//		FALSE: Probleme!
		
		
		
		this->STATISTIQUES_Envoie++;
		this->STATISTIQUES_Reception++;
		
		
		int Resultat_close 		= 0;	
		int Resultat_shutdown 	= 0;
		
		
		usleep(this->THREAD_PRIORITE_SLEEP);
		
		ENTRER_SectionCritiqueMT();
		if(Socket)
			Resultat_shutdown = shutdown(Socket, 2);
		
		if(Resultat_shutdown != 0) 
		{
			this->Erreur_STR = std::string("shutdown():");
			this->Erreur_STR = this->Erreur_STR + std::string(strerror(errno));
			SORTIR_SectionCritiqueMT();
			return false; // Probleme
		}
		
		SORTIR_SectionCritiqueMT();
		usleep(this->THREAD_PRIORITE_SLEEP);
		ENTRER_SectionCritiqueMT();
		
		if(Socket)
			Resultat_close = close(Socket);
		
		if(Resultat_close != 0) 
		{
			this->Erreur_STR = std::string("close():");
			this->Erreur_STR = this->Erreur_STR + std::string(strerror(errno));
			SORTIR_SectionCritiqueMT();
			return false; // Probleme
		}
		SORTIR_SectionCritiqueMT();
		return true;
	}
	
	bool cpinti_socket::Fermer_TOUT_Clients()
	{
		// Cette fonction permet de fermer TOUS les clients connectes
		bool NoProbleme = false;
		if(this->Type_PROTO == INIT_SERVEUR_UDP) /* Nettoyer les clients UDP */
		{
			// ...
		}
		else /* Nettoyer les clients TCP */
			for(unsigned int b = 0; b < this->TAB_InfoClient.size();  b++)
			{
				// Fermer tous les vectors qui ont minimum un port ET un socket superieur a 0 (securite)
				if((this->TAB_InfoClient[b].port > 0) && (this->TAB_InfoClient[b].socket > 0))
					if(Fermer_SocketClient(this->TAB_InfoClient[b].socket) == false)
						NoProbleme = false;
			}
		return NoProbleme;
	}
	
	bool cpinti_socket::Fermer_SocketClient()
	{
		return Fermer_SocketClient(this->Lecture_Client);
	}
	
	
	bool cpinti_socket::Fermer_SocketClient(int SocketClient)
	{
		// Cette fonction permet de fermer "correctement" un socket précis
		// Retourne
		//		TRUE : OK
		//		FALSE: Probleme!
		
		
		int Resultat_close		= 0;	
		int Resultat_shutdown	= 0;
		
		this->STATISTIQUES_Envoie++;
		this->STATISTIQUES_Reception++;
		
		
		usleep(this->THREAD_PRIORITE_SLEEP); // Attendre qu'on soit sur qu'il est tout recu!
		ENTRER_SectionCritiqueMT();
		
		if(SocketClient)
			Resultat_shutdown = shutdown(SocketClient, 2);
		
		if(Resultat_shutdown != 0) 
		{
			this->Erreur_STR = std::string("shutdown():");
			this->Erreur_STR = this->Erreur_STR + std::string(strerror(errno));
			SORTIR_SectionCritiqueMT();
			return false; // Probleme
		}
		
		SORTIR_SectionCritiqueMT();
		// Attendre qu'on soit sur qu'il est tout recu!
		usleep(this->THREAD_PRIORITE_SLEEP);
		ENTRER_SectionCritiqueMT();

		// Supprimer depuis le descripteur principal
		FD_CLR(SocketClient, &this->FD_socket);
		
		if(SocketClient)
			Resultat_close = close(SocketClient);
		
		if(Resultat_close != 0) 
		{
			this->Erreur_STR = std::string("close():");
			this->Erreur_STR = this->Erreur_STR + std::string(strerror(errno));
			SORTIR_SectionCritiqueMT();
			return false; // Probleme
		}
		
		// Si on est un serveur TCP ou UDP
		if((this->Type_PROTO != INIT_CLIENT_TCP) && (this->Type_PROTO != INIT_CLIENT_UDP))
		{
			// On supprime definitivement les info du client
			for(unsigned int b = 0; b < this->TAB_InfoClient.size(); b++)
			{
				if(this->TAB_InfoClient[b].socket == SocketClient)
				{
					this->TAB_InfoClient[b].socket 		= 0;
					this->TAB_InfoClient[b].port 		= 0;
					this->TAB_InfoClient[b].ipv4_STR	= "";
					
					// Se fait a la desctruction pour cause de reallocation memoire (+modif index)
					// this->TAB_InfoClient.erase (&this->TAB_InfoClient.at(b));
					break;
				}
			}
		}
		
		// Reduit le nombre de connectes
		this->NombreClient_Connectes--; 
		
		SORTIR_SectionCritiqueMT();
		return true;
	}
	
	bool cpinti_socket::Fermeture_differe_UPDATE()
	{
		// Met a jour et ferme un socket des que possible
		
		for(int boucle = 0; boucle <= _DEFFERE_FERME-1; boucle++)
		{
			if(this->Ferm_differe_COMP[boucle] > _DEFFERE_FERME - 4 /*Nombre cycles MAX */) // Il y a quelque chose a fermer au bout
			{
				// Nombre de cycles max atteint! 
		
				// On libere l'emplacement
				this->Ferm_differe_COMP[boucle] = 0;
				
				if(Ferm_differe_SOCK[boucle] > 0)
					// Puis on ferme le socket!
					return Fermer_SocketClient(this->Ferm_differe_SOCK[boucle]);
			}
			
			// Si un socket est en attente de fin de cycle
			if(this->Ferm_differe_COMP[boucle] > 0) 
				this->Ferm_differe_COMP[boucle]++;  // On augmente le nombre de cycles
		}

		return false; // Rien n'a ete fermer
	}
	
	bool cpinti_socket::Fermeture_differe_ADD(int Socket)
	{
		for(int boucle = 0; boucle <= _DEFFERE_FERME-1; boucle++)
		{
			if(this->Ferm_differe_COMP[boucle] == 0) // Emplacement libre
			{
				this->Ferm_differe_COMP[boucle] = 1; // Comptage des cycles ACTIVE
				this->Ferm_differe_SOCK[boucle] = Socket;
				
				return true; // OK
			}
		}
		
		return false; // Plus de places ...
	}
	
	/* = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = */
	std::string cpinti_socket_LOCAL::Erreur_STR = "";
	std::string cpinti_socket_LOCAL::get_Erreur()
	{
		// Retourner l'erreur provoque
		return cpinti_socket_LOCAL::Erreur_STR;
	}
	
    bool cpinti_socket_LOCAL::TestAdresseIPv4(const std::string &adresse)
	{
		// Tester si la forme IPv4 est repectee ou non
		//  Permet aussi de savoir si on peut utiliser gethostbyname() ou non.
		//  adresse	: "Adresse IP"
		// Retourne
		//		VRAIS si la forme est repectee
		//		FAUX si la forme n'est pas respectee
		
		ENTRER_SectionCritiqueMT();
		
		// Attributs
		char Point;
		unsigned int Valeur;
		std::istringstream buffeur(adresse);
		
		// Cherche si c'est inferieur a 255 et que les '.' sont presents
		for(size_t i=0; i<3; ++i) {
			if((!(buffeur >> Valeur)) || (Valeur > 255)) return false;
			if((!(buffeur >> Point)) || (Point != '.')) return false;
		}
		
		SORTIR_SectionCritiqueMT();
		// On test les deux conditions sont vrais
		return (buffeur >> Valeur) && (Valeur <= 255);
    }	
}